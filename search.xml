<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Tips 1</title>
      <link href="/posts/6063fc3b.html"/>
      <url>/posts/6063fc3b.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组和切片"><a class="markdownIt-Anchor" href="#数组和切片"></a> 数组和切片</h2><ol><li><p>初始化数组时可以通过索引来指定值，并且可以和按顺序指定值混用</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>                    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素全部为 0</span><span class="hljs-keyword">var</span> b = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}       <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 1, 2, 3</span><span class="hljs-keyword">var</span> c = [...]<span class="hljs-type">int</span>{<span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">1</span>: <span class="hljs-number">2</span>}    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 0, 2, 3</span><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>} <span class="hljs-comment">// 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6</span></code></pre></li><li><p><code>var times [5][0]int</code> 不会初始化数组（没有占用内存空间），但是可以遍历</p><pre class="highlight"><code class="go">    <span class="hljs-keyword">var</span> times [<span class="hljs-number">5</span>][<span class="hljs-number">0</span>]<span class="hljs-type">int</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> times {     fmt.Println(<span class="hljs-string">"hello"</span>) }</code></pre></li><li><p>如果衍生切片发生变化，那么原始切片（数组）以及它的所有的衍生切片在对应位置上的元素都会发生变化，因为这些切片都指向了同一一片内存空间，没有分配新的空间。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">string</span>{<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>, <span class="hljs-string">"6"</span>}b := a[:<span class="hljs-number">5</span>]c := a[<span class="hljs-number">2</span>:]a[<span class="hljs-number">2</span>] = <span class="hljs-string">"a"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)b[<span class="hljs-number">3</span>] = <span class="hljs-string">"b"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)c[<span class="hljs-number">2</span>] = <span class="hljs-string">"c"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)<span class="hljs-comment">// output</span><span class="hljs-comment">// a= [0 1 a 3 4 5 6]</span><span class="hljs-comment">// b= [0 1 a 3 4]</span><span class="hljs-comment">// c= [a 3 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b 4 5 6]</span><span class="hljs-comment">// b= [0 1 a b 4]</span><span class="hljs-comment">// c= [a b 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b c 5 6]</span><span class="hljs-comment">// b= [0 1 a b c]</span><span class="hljs-comment">// c= [a b c 5 6]</span></code></pre></li><li><p>在对切片进行一些操作时，我们可以利用特性 3 尽可能的少分配内存。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">int</span>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}<span class="hljs-keyword">var</span> c []<span class="hljs-type">int</span>c = <span class="hljs-built_in">append</span>(c, a[:<span class="hljs-number">2</span>]...)c = <span class="hljs-built_in">append</span>(c, a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(c)b := <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(b)<span class="hljs-comment">//output:</span><span class="hljs-comment">//[0 1 2 3 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span><span class="hljs-comment">//[0 1 5 6 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span></code></pre></li></ol><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><ol><li><p>通过下标获取到的是一个 <code>uint8</code> 类型的数字（字节）</p></li><li><p>通过<code>for...range</code>遍历，go 会努力解码成一个一个的<code>uint32</code>（即<code>rune</code>），索引则是每个<code>rune</code>第一个 byte 在该字符串对应 byte 数组中的位置</p><pre class="highlight"><code class="go">s := <span class="hljs-string">"hello, 世界"</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s {fmt.Printf(<span class="hljs-string">"index:%d\t value:%v(%T)\n"</span>, i, v, v)}<span class="hljs-comment">// output:</span><span class="hljs-comment">// index:0  value:104(int32)</span><span class="hljs-comment">// index:1  value:101(int32)</span><span class="hljs-comment">// index:2  value:108(int32)</span><span class="hljs-comment">// index:3  value:108(int32)</span><span class="hljs-comment">// index:4  value:111(int32)</span><span class="hljs-comment">// index:5  value:44(int32)</span><span class="hljs-comment">// index:6  value:32(int32)</span><span class="hljs-comment">// index:7  value:19990(int32)</span><span class="hljs-comment">// index:10         value:30028(int32)</span></code></pre></li></ol><h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2><ol><li><p>结构体的方法可以转换为函数，这个函数第一个参数就是结构体实例的指针。同理接口也一样，唯一的区别是接口本身隐含了指针。</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> f = (*Foo).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)<span class="hljs-keyword">type</span> SelfIntroduce <span class="hljs-keyword">interface</span> {SelfIntroduce(where <span class="hljs-type">string</span>)}<span class="hljs-keyword">var</span> f = (SelfIntroduce).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>useEffect infinite loop with dependencies</title>
      <link href="/posts/f37b0db4.html"/>
      <url>/posts/f37b0db4.html</url>
      
        <content type="html"><![CDATA[<h2 id="副作用钩子useeffect"><a class="markdownIt-Anchor" href="#副作用钩子useeffect"></a> 副作用钩子：useEffect</h2><p>当需要每次在 React 组件渲染后执行某些操作时，可以通过这个钩子来注册一个副作用函数<code>effect</code>。默认情况下 React 在第一次页面渲染之后以及后续页面的每次更新后都会执行这个<code>effect</code>。</p><p>另外，副作用函数可以返回一个函数，React 会在卸载组件执行清除操作时候调用这个返回的函数，意味着可以在其中加入一些清理工作。实际上，因为 React 会在每次渲染后都会执行<code>effect</code>，它会在调用一个新的<code>effect</code>之前对前一个<code>effect</code>进行清理，所以如果页面如果发生了渲染，清理也会先执行。</p><p>useEffect 的第二个参数可以传入一个数组指定依赖的数据，当这些数据发生了变化时才执行<code>effect</code>。</p><h2 id="无限更新问题分析以及解决"><a class="markdownIt-Anchor" href="#无限更新问题分析以及解决"></a> 无限更新问题分析以及解决</h2><p>这两天写了点代码测试时发现页面出现了无限循环更新，</p><blockquote><p>Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn’t have a dependency array, or one of the dependencies changes on every render.</p></blockquote><p>主要代码如下：</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-comment">// 设置过滤器</span><span class="hljs-keyword">const</span> [filters, setFilters] = <span class="hljs-title function_">useState</span>(tags);<span class="hljs-comment">// 这里的本意是在 data 更新时更新过滤器</span><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [tags]);</code></pre><p>在这段代码中，我总认为数据从远端加载之后，<code>tags</code>没有发生变化，<code>setFilters(tags)</code> 应该只会执行一次。现实情况是，<code>setFilters(tags)</code>执行之后，页面发生了渲染，触发了<code>tags</code>的重新计算，尽管数组内容没有变化但对象发生了变化，React 再次执行<code>setFilters(tags)</code>，然后再渲染再执行……，最终 React 无限的执行<code>setFilters(tags)</code>。</p><p>其实 tags 只是一个衍生的中间量，过滤器本质是要在 data 变化后才更新，因此这段代码只需简单改下就正常了。</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据，在这里 useRequest 只会执行一次远程数据拉取，因此 data 不会发生变化。</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [data]); <span class="hljs-comment">// 这里更新依赖改为 data</span></code></pre><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://react.dev/reference/react/useEffect">Reference: useEffect</a><br><a href="https://zh-hans.react.dev/reference/react/useEffect">中文 Reference: useEffect</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
