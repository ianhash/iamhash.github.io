<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-14T06:39:26.942Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>开始学习 kubernetes</title>
    <link href="http://example.com/posts/f38c21ef.html"/>
    <id>http://example.com/posts/f38c21ef.html</id>
    <published>2024-04-14T06:39:03.000Z</published>
    <updated>2024-04-14T06:39:26.942Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍我在自己的 ubuntu 系统上搭建 kubernetes 学习环境的过程，在阅读了一些文档之后，我大致将按照以下清单来逐步搭建一个本地测试集群，部署并启动一个 tomcat 实例。</p><ol><li>安装 kubectl 以便后续启动本地测试集群后可以通过 kubectl 访问</li><li>使用 podman 提供容器服务</li><li>通过 kind 初始化并启动一个 k8s 集群</li><li>部署并启动一个 tomecat 实例</li></ol><h2 id="安装-kubectl"><a class="markdownIt-Anchor" href="#安装-kubectl"></a> 安装 kubectl</h2><p>安装方法参考官方文档：<a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</a></p><pre class="highlight"><code class="bash">curl -LO <span class="hljs-string">"https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl"</span></code></pre><p>验证一下安装包：</p><pre class="highlight"><code class="bash">curl -LO <span class="hljs-string">"https://dl.k8s.io/release/<span class="hljs-subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl.sha256"</span><span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-subst">$(cat kubectl.sha256)</span>  kubectl"</span> | <span class="hljs-built_in">sha256sum</span> --check</code></pre><p>如果安装包没有问题的话，将输出 <code>kubectl: OK</code>，然后执行以下命令安装：</p><pre class="highlight"><code class="bash">sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</code></pre><p>可以执行 <code>kubectl version --client</code> 检查下安装版本。</p><h2 id="安装-podman"><a class="markdownIt-Anchor" href="#安装-podman"></a> 安装 podman</h2><p>ubuntu 22.04 下通过 apt 在安装 podman 的版本是 3.4.4，这个版本太旧了，会有很多问题，通过查网上的资料发现 homebrew 也支持 ubuntu 系统，所以跟着 homebrew 的安装指引先把 homebrew 安装了，然后再通过 homebrew 安装最新版本的 podman。</p><blockquote><p>这个安装过程比较长，国内使用 brew 的话还是需要网络加速才能有稍微好的下载体验，如果你有工具的话，可以在终端执行 <code>export https_proxy=...</code> 为终端加上加速代理</p></blockquote><pre class="highlight"><code class="bash">brew install podman</code></pre><p>安装完成之后，注意看 brew 的安装提示，我没有选择使 podman 随系统启动，</p><pre class="highlight"><code class="">zsh completions have been installed to:  /home/linuxbrew/.linuxbrew/share/zsh/site-functionsTo start podman now and restart at login:  brew services start podmanOr, if you don't want/need a background service you can just run:  /home/linuxbrew/.linuxbrew/opt/podman/bin/podman system service --time\=0</code></pre><blockquote><p>我手动启动 podman，出现 newuidmap 没有可执行的文件的的错误 <code>exec: "newuidmap": executable file not found in $PATH</code>，通过 <code>sudo apt-get install uidmap</code> 解决</p></blockquote><p>通过启动一个 hello-world 来测试 podman 以及正确安装，</p><pre class="highlight"><code class="bash">podman run hello-world</code></pre><p>它会从 <a href="http://docker.io">docker.io</a> 拉取 hello-world 镜像并运行，不出意外终端将输出一些表示安装成功的信息，比如在我的电脑上，如下</p><pre class="highlight"><code class="">Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.</code></pre><h3 id="问题和解决办法"><a class="markdownIt-Anchor" href="#问题和解决办法"></a> 问题和解决办法</h3><ol><li><p><code>failed to find plugin "bridge"</code><br>可以通过 <code>sudo apt install containernetworking-plugins</code> 解决，但还是老问题，这个安装下来的版本是<code>0.9</code>，我最终选择从 github 下载最新的 release 手动安装，从代码 <a href="https://github.com/containers/common/blob/main/pkg/config/default.go#L83">https://github.com/containers/common/blob/main/pkg/config/default.go#L83</a> 中可以看到 podman 从以下目录获取 cni 插件:</p><pre class="highlight"><code class="go">DefaultCNIPluginDirs = []<span class="hljs-type">string</span>{<span class="hljs-string">"/usr/local/libexec/cni"</span>,<span class="hljs-string">"/usr/libexec/cni"</span>,<span class="hljs-string">"/usr/local/lib/cni"</span>,<span class="hljs-string">"/usr/lib/cni"</span>,<span class="hljs-string">"/opt/cni/bin"</span>,  }</code></pre><p>因此从 github 下载最新的 release 之后，解压到以上任意目录即可。</p><pre class="highlight"><code class="bash">sudo <span class="hljs-built_in">mkdir</span> -p /usr/local/libexec/cnisudo tar -xzf ./Downloads/cni-plugins-linux-amd64-v1.4.0.tgz -C /usr/local/libexec/cni</code></pre><p>解压之后，执行 <code>podman system reset --force</code>刷新一下。</p></li><li><p><code>failed to find plugin "dnsname"</code><br><a href="https://github.com/containers/dnsname?tab=readme-ov-file">dnsname</a> 这个项目已经不再维护了，取而代之的是<a href="https://github.com/containers/netavark/">netavark</a>，同时在前面看到的 podman 代码里我们同样可以看到最新的 podman 支持 netavark，</p><pre class="highlight"><code class="go"> DefaultNetavarkPluginDirs = []<span class="hljs-type">string</span>{   <span class="hljs-string">"/usr/local/libexec/netavark"</span>,   <span class="hljs-string">"/usr/libexec/netavark"</span>,   <span class="hljs-string">"/usr/local/lib/netavark"</span>,   <span class="hljs-string">"/usr/lib/netavark"</span>, }</code></pre><p>那么索性我们就用最新的方案。在 netavark 项目下找到最新的 release 文件，下载并解压到 <code>/usr/local/libexec/netavark</code>，</p><pre class="highlight"><code class="bash">sudo <span class="hljs-built_in">mkdir</span> -p /usr/local/libexec/netavarksudo gzip -d ./netavark.gzsudo <span class="hljs-built_in">cp</span> -fr netavark /usr/local/libexec/netavarksudo <span class="hljs-built_in">chmod</span> +x /usr/local/libexec/netavark/netavark</code></pre><p>为了让 podman 能使用 netavark，需要作个配置，配置参考：<a href="https://github.com/containers/common/blob/main/docs/containers.conf.5.md%EF%BC%8C%E6%88%91%E9%80%89%E6%8B%A9%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%60$HOME/.config/containers/containers.conf%60%E5%B9%B6%E5%9C%A8%E5%85%B6%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%B8%80%E8%A1%8C%E9%85%8D%E7%BD%AE:">https://github.com/containers/common/blob/main/docs/containers.conf.5.md，我选择创建文件`$HOME/.config/containers/containers.conf`并在其中加入一行配置:</a></p><pre class="highlight"><code class="ini"><span class="hljs-attr">network_backend</span>=<span class="hljs-string">"netavark"</span></code></pre></li></ol><p>kind 默认使用 docker 作为容器引擎，为了使 kind 能使用 podman，还需要配置一下 shell，我使用 zsh，因此在 .zshrc 中增加如下代码：</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># kind with podman</span><span class="hljs-built_in">alias</span> docker=podmanKIND_EXPERIMENTAL_PROVIDER=podman</code></pre><h2 id="安装-kind"><a class="markdownIt-Anchor" href="#安装-kind"></a> 安装 kind</h2><p>首先要安装 kind，kind 也是一个 go 项目，安装方式是通过<code>go get</code>，所以安装 kind 之前需要首先安装 go 并完成相应的设置。</p><p>同样可以通过 apt 来安装 go，我是从官网下载 go 的安装包安装的，无论如何安装，一个比较重要的设置是<code>GOPROXY</code>。</p><pre class="highlight"><code class="bash">go <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.cn,direct</code></pre><p>然后就可以安装 kind 了，</p><pre class="highlight"><code class="bash">go install sigs.k8s.io/kind@v0.20.0</code></pre><p>go 会将 kind 以及相关的依赖全部安装到 GOPATH 下，而 GOPATH 默认就是你 HOME 目录下的 go 文件夹，可以通过<code>go env GOPATH</code>来查看，可以在<code>.bashrc</code>或者<code>.zshrc</code>中加入一行：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/go/bin</code></pre><p>重启终端工具之后可以直接使用 kind 命令了，可以使用 <code>kind version</code> 测试一下。</p><h2 id="kind-初体验"><a class="markdownIt-Anchor" href="#kind-初体验"></a> kind 初体验</h2><p>通过<code>kind --help</code>可以大致浏览下 kind 有哪些命令选项可用。</p><pre class="highlight"><code class="">kind creates and manages local Kubernetes clusters using Docker container 'nodes'Usage:  kind [command]Available Commands:  build       Build one of [node-image]  completion  Output shell completion code for the specified shell (bash, zsh or fish)  create      Creates one of [cluster]  delete      Deletes one of [cluster]  export      Exports one of [kubeconfig, logs]  get         Gets one of [clusters, nodes, kubeconfig]  help        Help about any command  load        Loads images into nodes  version     Prints the kind CLI versionFlags:  -h, --help              help for kind      --loglevel string   DEPRECATED: see -v instead  -q, --quiet             silence all stderr output  -v, --verbosity int32   info log verbosity, higher value produces more output      --version           version for kindUse "kind [command] --help" for more information about a command.</code></pre><blockquote><p>这里有意思的是通过 <code>kind completion</code> 可以看到不同终端下命令自动填充的方法，建议跟着说明配置一下，在终端下输入相关命令可以达到事半功倍的效果。</p></blockquote><p>这个时候使用<code>kind get clusters</code>可以看到命令 kind 已经使用 podman 作为容器引擎并且目前还没有任何集群。</p><pre class="highlight"><code class="">enabling experimental podman providerNo kind clusters found.</code></pre><p>为了以普通账户运行 kind，还需要进行一些配置，我参考官方文档：<a href="https://kind.sigs.k8s.io/docs/user/rootless/">https://kind.sigs.k8s.io/docs/user/rootless/</a> 进行配置但无法成功创建集群。错误如下：</p><pre class="highlight"><code class="bash">(base) ➜  ~ kind create clusterenabling experimental podman providerERROR: failed to create cluster: running kind with rootless provider requires setting systemd property <span class="hljs-string">"Delegate=yes"</span>, see https://kind.sigs.k8s.io/docs/user/rootless/</code></pre><p>我暂时还不太懂<code>systemd</code>那套东西，所以我也没有调查清除这个问题的原因，我想未来再对 systemd 进行系统性的学习，现在首要工作是解决 kind 创建集群的问题。我在查阅了网上很多文档之后在这里找到了解决方法。<a href="https://github.com/kubernetes-sigs/kind/issues/2916">Running with rootless podman seems not to respect property Delegate=yes</a></p><p>似乎按照 kind 文档中说的在<code>/etc/systemd/system/user@.service.d/delegate.conf</code>文件中配置的<code>Delegate=yes</code>没有生效，但我们可以在创建集群时加上<code>--property=Delegate=yes</code>参数，即</p><pre class="highlight"><code class="bash">systemd-run --user --property=Delegate=<span class="hljs-built_in">yes</span> kind create cluster</code></pre><p>现在终于可以看到理想的结果了：</p><pre class="highlight"><code class="">(base) ➜  ~ systemd-run --scope  --user --property=Delegate=yes kind create clusterRunning as unit: run-r3e7e2ade31574b7ba03fece7b1b70d02.scope; invocation ID: 82c73452ecb240be9fc5f8cad084b879enabling experimental podman providerCreating cluster "kind" ... ✓ Ensuring node image (kindest/node:v1.27.3) 🖼 ✓ Preparing nodes 📦 ✓ Writing configuration 📜 ✓ Starting control-plane 🕹️ ✓ Installing CNI 🔌 ✓ Installing StorageClass 💾Set kubectl context to "kind-kind"You can now use your cluster with:kubectl cluster-info --context kind-kindHave a nice day! 👋</code></pre><p>从这个输出信息看不仅创建了一个名为 kind 的集群，还为我们把 kubectl 也配置好了，现在可以检查下。</p><pre class="highlight"><code class="">(base) ➜  ~ kind get clustersenabling experimental podman providerkind(base) ➜  ~ kind get nodesenabling experimental podman providerkind-control-plane(base) ➜  ~ kubectl get nodeNAME                 STATUS   ROLES           AGE    VERSIONkind-control-plane   Ready    control-plane   7m7s   v1.27.3</code></pre><h2 id="创建一个测试集群"><a class="markdownIt-Anchor" href="#创建一个测试集群"></a> 创建一个测试集群</h2><p>一个测试集群怎么说也至少要有一个节点，可以通过一个 yaml 文件配置集群。</p><pre class="highlight"><code class="yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><span class="hljs-attr">name:</span> <span class="hljs-string">kindtest</span><span class="hljs-attr">nodes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span>    <span class="hljs-attr">kubeadmConfigPatches:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">|        kind: InitConfiguration        nodeRegistration:          kubeletExtraArgs:            node-labels: "ingress-ready=true"</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span></code></pre><p>执行 kind 创建集群的命令</p><pre class="highlight"><code class="bash">systemd-run --scope  --user --property=Delegate=<span class="hljs-built_in">yes</span> kind create cluster --config=./kindtest.yaml</code></pre><p>稍微等待过后 kind 会为我们创建包含一个节点的集群，通过 <code>kubectl get nodes</code> 检查一下:</p><pre class="highlight"><code class="bash">➜  Devops kubectl get nodesNAME                     STATUS   ROLES           AGE   VERSIONkindtest-control-plane   Ready    control-plane   18m   v1.27.3kindtest-worker          Ready    &lt;none&gt;          18m   v1.27.3</code></pre><p>同时我们也可以看一下当前集群有那些 pod，我通过以下命令把 pod 的 namespace/name/nodeName 输出来</p><pre class="highlight"><code class="bash">kubectl get pods -A -o jsonpath=<span class="hljs-string">"{range .items[*]}{.metadata.namespace}{'\t'}{.metadata.name}{'\t'}{.spec.nodeName}{'\n'}{end}"</span></code></pre><p>输出结果:</p><pre class="highlight"><code class="">kube-systemcoredns-5d78c9869d-n6qjrkindtest-control-planekube-systemcoredns-5d78c9869d-v9bkmkindtest-control-planekube-systemetcd-kindtest-control-planekindtest-control-planekube-systemkindnet-8r4h8kindtest-control-planekube-systemkindnet-n4d6jkindtest-workerkube-systemkube-apiserver-kindtest-control-planekindtest-control-planekube-systemkube-controller-manager-kindtest-control-planekindtest-control-planekube-systemkube-proxy-bksh8kindtest-control-planekube-systemkube-proxy-vzv5pkindtest-workerkube-systemkube-scheduler-kindtest-control-planekindtest-control-planelocal-path-storagelocal-path-provisioner-6bc4bddd6b-8w9jvkindtest-control-plane</code></pre><p>通过这些输出可以了解到节点<code>kindtest-control-plane</code> 包含了 k8s 运行的必要组建包括 apiserver, etcd, kubeproxy, kube-scheduler 等。</p><h2 id="部署-tomcat"><a class="markdownIt-Anchor" href="#部署-tomcat"></a> 部署 tomcat</h2><p>在创建 depleymnent 之前，我们先创建一个 namespace，</p><pre class="highlight"><code class="bash">kubectl create namespace k8slearn</code></pre><p>然后准备 deployment 配置，并执行<code>kubectl apply -f ./k8slearn-tomcatapp-deployment.yaml</code></p><pre class="highlight"><code class="yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">get-started-with-k8s</span>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">k8slearn</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">k8slearn</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">k8slearn</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">tomcat</span>          <span class="hljs-attr">name:</span> <span class="hljs-string">main</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span></code></pre><p>不出意外，稍等一会儿一个pod就会创建出来。</p><pre class="highlight"><code class="bash">(base) ➜  kubectl get pod -n k8slearn                                              NAME                                    READY   STATUS    RESTARTS   AGEget-started-with-k8s-6487fc8787-tp5bh   1/1     Running   0          6m25s</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍我在自己的 ubuntu 系统上搭建 kubernetes 学习环境的过程，在阅读了一些文档之后，我大致将按照以下清单来逐步搭建一个本地测试集群，部署并启动一个 tomcat 实例。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装 kubectl 以便后续启动本地测试集群后可以</summary>
      
    
    
    
    <category term="云原生" scheme="http://example.com/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
    <category term="ubuntu" scheme="http://example.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>get started with rust</title>
    <link href="http://example.com/posts/8ca469cd.html"/>
    <id>http://example.com/posts/8ca469cd.html</id>
    <published>2024-04-10T01:02:44.000Z</published>
    <updated>2024-04-10T01:02:51.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><blockquote><p>Rustup 是一个命令行应用，它是 Rust 的工具链管理器，负责安装、更新和管理 Rust 工具链。工具链包括编译器、标准库、文档、工具以及其他与 Rust 开发相关的组件。rustup 提供了一个统一的接口，通过它可以轻松地安装和使用 Rust。此外，rustup 还可以安装和更新其他 Rust 工具，如 cargo、Rust 文档工具等。同时，rustup 也能够在不同版本的 Rust 工具链中进行切换，包括编译器 rustc 和标准库。</p></blockquote><p>在 macos 上安装 rustup 非常简单，执行以下命令在向导指引下就能完成安装，</p><pre class="highlight"><code class="bash">brew install rustup-init</code></pre><p>安装成功后可以执行<code>rustc --version</code> 查看安装好的 rust 版本信息。如：</p><pre class="highlight"><code class="bash">(base) ➜  Codes rustc --versionrustc 1.75.0 (82e1608df 2023-12-21)</code></pre><p>同时，cargo 也安装好了，</p><pre class="highlight"><code class="bash">(base) ➜  Codes cargo --versioncargo 1.75.0 (1d8b05cdd 2023-11-20)</code></pre><blockquote><p>Cargo 是一个官方的构建系统和包管理器。它是 Rust 生态系统中用于构建和运行 Rust 应用程序的标准工具。Cargo 极大地简化了项目的构建过程，提供了依赖项管理，以及一系列方便的工作流程工具，极大提升了开发效率和协作体验。</p></blockquote><h2 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h2><p>在任意一个目录下，创建 <a href="http://main.rs">main.rs</a> 文件，代码如下：</p><pre class="highlight"><code class="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hello world"</span>)}</code></pre><p>然后执行编译并运行程序，</p><pre class="highlight"><code class="bash">rustc ./main.rs./main</code></pre><h2 id="体验-cargo"><a class="markdownIt-Anchor" href="#体验-cargo"></a> 体验 Cargo</h2><p>我们可以把上一节的程序按照 cargo 项目的标准目录结构进行调整，假设项目路径为<code>${project}</code></p><ol><li>新建<code>${project}/src</code>目录并且把<code>main.rs</code>移动到这个目录</li><li>新建一个<code>${project}/Cargo.toml</code>文件，文件内容如下：</li></ol><pre class="highlight"><code class="toml"><span class="hljs-section">[package]</span><span class="hljs-attr">name</span> = <span class="hljs-string">"hello-world"</span><span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span><span class="hljs-attr">edition</span> = <span class="hljs-string">"2021"</span><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><span class="hljs-section">[dependencies]</span></code></pre><p>此时在<code>${project}</code>目录下，执行<code>cargo build</code>，cargo 会调用相应的工具进行编译，你将在目录下看到新生成的 target 目录，其中就包含了已经编译好的 hello-world 二进制可执行文件，可以直接执行这个文件：</p><pre class="highlight"><code class="bash">git:(main) ✗ ./target/debug/hello-worldhello world</code></pre><p>另外通过 cargo 也可以执行，如下：</p><pre class="highlight"><code class="bash">git:(main) ✗ cargo run    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.00s     Running `target/debug/hello-world`hello world</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Rustup 是一个命令行应用，它是 Rust 的工具链管理器，负责安装、更新和管理 Rust 工具链。工具链包括编译</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Go Tips 1</title>
    <link href="http://example.com/posts/6063fc3b.html"/>
    <id>http://example.com/posts/6063fc3b.html</id>
    <published>2024-04-10T00:14:30.000Z</published>
    <updated>2024-04-10T00:15:21.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组和切片"><a class="markdownIt-Anchor" href="#数组和切片"></a> 数组和切片</h2><ol><li><p>初始化数组时可以通过索引来指定值，并且可以和按顺序指定值混用</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>                    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素全部为 0</span><span class="hljs-keyword">var</span> b = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}       <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 1, 2, 3</span><span class="hljs-keyword">var</span> c = [...]<span class="hljs-type">int</span>{<span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">1</span>: <span class="hljs-number">2</span>}    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 0, 2, 3</span><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>} <span class="hljs-comment">// 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6</span></code></pre></li><li><p><code>var times [5][0]int</code> 不会初始化数组（没有占用内存空间），但是可以遍历</p><pre class="highlight"><code class="go">    <span class="hljs-keyword">var</span> times [<span class="hljs-number">5</span>][<span class="hljs-number">0</span>]<span class="hljs-type">int</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> times {     fmt.Println(<span class="hljs-string">"hello"</span>) }</code></pre></li><li><p>如果衍生切片发生变化，那么原始切片（数组）以及它的所有的衍生切片在对应位置上的元素都会发生变化，因为这些切片都指向了同一一片内存空间，没有分配新的空间。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">string</span>{<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>, <span class="hljs-string">"6"</span>}b := a[:<span class="hljs-number">5</span>]c := a[<span class="hljs-number">2</span>:]a[<span class="hljs-number">2</span>] = <span class="hljs-string">"a"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)b[<span class="hljs-number">3</span>] = <span class="hljs-string">"b"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)c[<span class="hljs-number">2</span>] = <span class="hljs-string">"c"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)<span class="hljs-comment">// output</span><span class="hljs-comment">// a= [0 1 a 3 4 5 6]</span><span class="hljs-comment">// b= [0 1 a 3 4]</span><span class="hljs-comment">// c= [a 3 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b 4 5 6]</span><span class="hljs-comment">// b= [0 1 a b 4]</span><span class="hljs-comment">// c= [a b 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b c 5 6]</span><span class="hljs-comment">// b= [0 1 a b c]</span><span class="hljs-comment">// c= [a b c 5 6]</span></code></pre></li><li><p>在对切片进行一些操作时，我们可以利用特性 3 尽可能的少分配内存。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">int</span>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}<span class="hljs-keyword">var</span> c []<span class="hljs-type">int</span>c = <span class="hljs-built_in">append</span>(c, a[:<span class="hljs-number">2</span>]...)c = <span class="hljs-built_in">append</span>(c, a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(c)b := <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(b)<span class="hljs-comment">//output:</span><span class="hljs-comment">//[0 1 2 3 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span><span class="hljs-comment">//[0 1 5 6 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span></code></pre></li></ol><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><ol><li><p>通过下标获取到的是一个 <code>uint8</code> 类型的数字（字节）</p></li><li><p>通过<code>for...range</code>遍历，go 会努力解码成一个一个的<code>uint32</code>（即<code>rune</code>），索引则是每个<code>rune</code>第一个 byte 在该字符串对应 byte 数组中的位置</p><pre class="highlight"><code class="go">s := <span class="hljs-string">"hello, 世界"</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s {fmt.Printf(<span class="hljs-string">"index:%d\t value:%v(%T)\n"</span>, i, v, v)}<span class="hljs-comment">// output:</span><span class="hljs-comment">// index:0  value:104(int32)</span><span class="hljs-comment">// index:1  value:101(int32)</span><span class="hljs-comment">// index:2  value:108(int32)</span><span class="hljs-comment">// index:3  value:108(int32)</span><span class="hljs-comment">// index:4  value:111(int32)</span><span class="hljs-comment">// index:5  value:44(int32)</span><span class="hljs-comment">// index:6  value:32(int32)</span><span class="hljs-comment">// index:7  value:19990(int32)</span><span class="hljs-comment">// index:10         value:30028(int32)</span></code></pre></li></ol><h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2><ol><li><p>结构体的方法可以转换为函数，这个函数第一个参数就是结构体实例的指针。同理接口也一样，唯一的区别是接口本身隐含了指针。</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> f = (*Foo).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)<span class="hljs-keyword">type</span> SelfIntroduce <span class="hljs-keyword">interface</span> {SelfIntroduce(where <span class="hljs-type">string</span>)}<span class="hljs-keyword">var</span> f = (SelfIntroduce).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组和切片&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组和切片&quot;&gt;&lt;/a&gt; 数组和切片&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化数组时可以通过索引来指定值，并且可以和按顺序指定值混用&lt;/p&gt;
&lt;pre class=&quot;highli</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>useEffect infinite loop with dependencies</title>
    <link href="http://example.com/posts/f37b0db4.html"/>
    <id>http://example.com/posts/f37b0db4.html</id>
    <published>2023-11-17T22:10:47.000Z</published>
    <updated>2023-11-17T23:04:50.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="副作用钩子useeffect"><a class="markdownIt-Anchor" href="#副作用钩子useeffect"></a> 副作用钩子：useEffect</h2><p>当需要每次在 React 组件渲染后执行某些操作时，可以通过这个钩子来注册一个副作用函数<code>effect</code>。默认情况下 React 在第一次页面渲染之后以及后续页面的每次更新后都会执行这个<code>effect</code>。</p><p>另外，副作用函数可以返回一个函数，React 会在卸载组件执行清除操作时候调用这个返回的函数，意味着可以在其中加入一些清理工作。实际上，因为 React 会在每次渲染后都会执行<code>effect</code>，它会在调用一个新的<code>effect</code>之前对前一个<code>effect</code>进行清理，所以如果页面如果发生了渲染，清理也会先执行。</p><p>useEffect 的第二个参数可以传入一个数组指定依赖的数据，当这些数据发生了变化时才执行<code>effect</code>。</p><h2 id="无限更新问题分析以及解决"><a class="markdownIt-Anchor" href="#无限更新问题分析以及解决"></a> 无限更新问题分析以及解决</h2><p>这两天写了点代码测试时发现页面出现了无限循环更新，</p><blockquote><p>Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn’t have a dependency array, or one of the dependencies changes on every render.</p></blockquote><p>主要代码如下：</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-comment">// 设置过滤器</span><span class="hljs-keyword">const</span> [filters, setFilters] = <span class="hljs-title function_">useState</span>(tags);<span class="hljs-comment">// 这里的本意是在 data 更新时更新过滤器</span><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [tags]);</code></pre><p>在这段代码中，我总认为数据从远端加载之后，<code>tags</code>没有发生变化，<code>setFilters(tags)</code> 应该只会执行一次。现实情况是，<code>setFilters(tags)</code>执行之后，页面发生了渲染，触发了<code>tags</code>的重新计算，尽管数组内容没有变化但对象发生了变化，React 再次执行<code>setFilters(tags)</code>，然后再渲染再执行……，最终 React 无限的执行<code>setFilters(tags)</code>。</p><p>其实 tags 只是一个衍生的中间量，过滤器本质是要在 data 变化后才更新，因此这段代码只需简单改下就正常了。</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据，在这里 useRequest 只会执行一次远程数据拉取，因此 data 不会发生变化。</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [data]); <span class="hljs-comment">// 这里更新依赖改为 data</span></code></pre><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://react.dev/reference/react/useEffect">Reference: useEffect</a><br><a href="https://zh-hans.react.dev/reference/react/useEffect">中文 Reference: useEffect</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;副作用钩子useeffect&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#副作用钩子useeffect&quot;&gt;&lt;/a&gt; 副作用钩子：useEffect&lt;/h2&gt;
&lt;p&gt;当需要每次在 React 组件渲染后执行某些操作时，可以通过这个钩子来</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2023-06-03T02:04:36.140Z</published>
    <updated>2023-06-03T02:05:01.626Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
