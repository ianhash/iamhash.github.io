<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-10T01:02:44.081Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>get started with rust</title>
    <link href="http://example.com/posts/8ca469cd.html"/>
    <id>http://example.com/posts/8ca469cd.html</id>
    <published>2024-04-10T01:02:44.000Z</published>
    <updated>2024-04-10T01:02:44.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><blockquote><p>Rustup 是一个命令行应用，它是 Rust 的工具链管理器，负责安装、更新和管理 Rust 工具链。工具链包括编译器、标准库、文档、工具以及其他与 Rust 开发相关的组件。rustup 提供了一个统一的接口，通过它可以轻松地安装和使用 Rust。此外，rustup 还可以安装和更新其他 Rust 工具，如 cargo、Rust 文档工具等。同时，rustup 也能够在不同版本的 Rust 工具链中进行切换，包括编译器 rustc 和标准库。</p></blockquote><p>在 macos 上安装 rustup 非常简单，执行以下命令在向导指引下就能完成安装，</p><pre class="highlight"><code class="bash">brew install rustup-init</code></pre><p>安装成功后可以执行<code>rustc --version</code> 查看安装好的 rust 版本信息。如：</p><pre class="highlight"><code class="bash">(base) ➜  Codes rustc --versionrustc 1.75.0 (82e1608df 2023-12-21)</code></pre><p>同时，cargo 也安装好了，</p><pre class="highlight"><code class="bash">(base) ➜  Codes cargo --versioncargo 1.75.0 (1d8b05cdd 2023-11-20)</code></pre><blockquote><p>Cargo 是一个官方的构建系统和包管理器。它是 Rust 生态系统中用于构建和运行 Rust 应用程序的标准工具。Cargo 极大地简化了项目的构建过程，提供了依赖项管理，以及一系列方便的工作流程工具，极大提升了开发效率和协作体验。</p></blockquote><h2 id="hello-world"><a class="markdownIt-Anchor" href="#hello-world"></a> Hello World</h2><p>在任意一个目录下，创建 <a href="http://main.rs">main.rs</a> 文件，代码如下：</p><pre class="highlight"><code class="rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hello world"</span>)}</code></pre><p>然后执行编译并运行程序，</p><pre class="highlight"><code class="bash">rustc ./main.rs./main</code></pre><h2 id="体验-cargo"><a class="markdownIt-Anchor" href="#体验-cargo"></a> 体验 Cargo</h2><p>我们可以把上一节的程序按照 cargo 项目的标准目录结构进行调整，假设项目路径为<code>${project}</code></p><ol><li>新建<code>${project}/src</code>目录并且把<code>main.rs</code>移动到这个目录</li><li>新建一个<code>${project}/Cargo.toml</code>文件，文件内容如下：</li></ol><pre class="highlight"><code class="toml"><span class="hljs-section">[package]</span><span class="hljs-attr">name</span> = <span class="hljs-string">"hello-world"</span><span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span><span class="hljs-attr">edition</span> = <span class="hljs-string">"2021"</span><span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><span class="hljs-section">[dependencies]</span></code></pre><p>此时在<code>${project}</code>目录下，执行<code>cargo build</code>，cargo 会调用相应的工具进行编译，你将在目录下看到新生成的 target 目录，其中就包含了已经编译好的 hello-world 二进制可执行文件，可以直接执行这个文件：</p><pre class="highlight"><code class="bash">git:(main) ✗ ./target/debug/hello-worldhello world</code></pre><p>另外通过 cargo 也可以执行，如下：</p><pre class="highlight"><code class="bash">git:(main) ✗ cargo run    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.00s     Running `target/debug/hello-world`hello world</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Rustup 是一个命令行应用，它是 Rust 的工具链管理器，负责安装、更新和管理 Rust 工具链。工具链包括编译</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>Go Tips 1</title>
    <link href="http://example.com/posts/6063fc3b.html"/>
    <id>http://example.com/posts/6063fc3b.html</id>
    <published>2024-04-10T00:14:30.000Z</published>
    <updated>2024-04-10T00:15:21.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组和切片"><a class="markdownIt-Anchor" href="#数组和切片"></a> 数组和切片</h2><ol><li><p>初始化数组时可以通过索引来指定值，并且可以和按顺序指定值混用</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>                    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素全部为 0</span><span class="hljs-keyword">var</span> b = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}       <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 1, 2, 3</span><span class="hljs-keyword">var</span> c = [...]<span class="hljs-type">int</span>{<span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">1</span>: <span class="hljs-number">2</span>}    <span class="hljs-comment">// 定义长度为 3 的 int 型数组, 元素为 0, 2, 3</span><span class="hljs-keyword">var</span> d = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>: <span class="hljs-number">5</span>, <span class="hljs-number">6</span>} <span class="hljs-comment">// 定义长度为 6 的 int 型数组, 元素为 1, 2, 0, 0, 5, 6</span></code></pre></li><li><p><code>var times [5][0]int</code> 不会初始化数组（没有占用内存空间），但是可以遍历</p><pre class="highlight"><code class="go">    <span class="hljs-keyword">var</span> times [<span class="hljs-number">5</span>][<span class="hljs-number">0</span>]<span class="hljs-type">int</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> times {     fmt.Println(<span class="hljs-string">"hello"</span>) }</code></pre></li><li><p>如果衍生切片发生变化，那么原始切片（数组）以及它的所有的衍生切片在对应位置上的元素都会发生变化，因为这些切片都指向了同一一片内存空间，没有分配新的空间。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">string</span>{<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>, <span class="hljs-string">"2"</span>, <span class="hljs-string">"3"</span>, <span class="hljs-string">"4"</span>, <span class="hljs-string">"5"</span>, <span class="hljs-string">"6"</span>}b := a[:<span class="hljs-number">5</span>]c := a[<span class="hljs-number">2</span>:]a[<span class="hljs-number">2</span>] = <span class="hljs-string">"a"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)b[<span class="hljs-number">3</span>] = <span class="hljs-string">"b"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)c[<span class="hljs-number">2</span>] = <span class="hljs-string">"c"</span>fmt.Println(<span class="hljs-string">"a="</span>, a)fmt.Println(<span class="hljs-string">"b="</span>, b)fmt.Println(<span class="hljs-string">"c="</span>, c)<span class="hljs-comment">// output</span><span class="hljs-comment">// a= [0 1 a 3 4 5 6]</span><span class="hljs-comment">// b= [0 1 a 3 4]</span><span class="hljs-comment">// c= [a 3 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b 4 5 6]</span><span class="hljs-comment">// b= [0 1 a b 4]</span><span class="hljs-comment">// c= [a b 4 5 6]</span><span class="hljs-comment">// a= [0 1 a b c 5 6]</span><span class="hljs-comment">// b= [0 1 a b c]</span><span class="hljs-comment">// c= [a b c 5 6]</span></code></pre></li><li><p>在对切片进行一些操作时，我们可以利用特性 3 尽可能的少分配内存。</p><pre class="highlight"><code class="go">a := []<span class="hljs-type">int</span>{<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}<span class="hljs-keyword">var</span> c []<span class="hljs-type">int</span>c = <span class="hljs-built_in">append</span>(c, a[:<span class="hljs-number">2</span>]...)c = <span class="hljs-built_in">append</span>(c, a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(c)b := <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">5</span>:]...)fmt.Println(a)fmt.Println(b)<span class="hljs-comment">//output:</span><span class="hljs-comment">//[0 1 2 3 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span><span class="hljs-comment">//[0 1 5 6 4 5 6]</span><span class="hljs-comment">//[0 1 5 6]</span></code></pre></li></ol><h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2><ol><li><p>通过下标获取到的是一个 <code>uint8</code> 类型的数字（字节）</p></li><li><p>通过<code>for...range</code>遍历，go 会努力解码成一个一个的<code>uint32</code>（即<code>rune</code>），索引则是每个<code>rune</code>第一个 byte 在该字符串对应 byte 数组中的位置</p><pre class="highlight"><code class="go">s := <span class="hljs-string">"hello, 世界"</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> s {fmt.Printf(<span class="hljs-string">"index:%d\t value:%v(%T)\n"</span>, i, v, v)}<span class="hljs-comment">// output:</span><span class="hljs-comment">// index:0  value:104(int32)</span><span class="hljs-comment">// index:1  value:101(int32)</span><span class="hljs-comment">// index:2  value:108(int32)</span><span class="hljs-comment">// index:3  value:108(int32)</span><span class="hljs-comment">// index:4  value:111(int32)</span><span class="hljs-comment">// index:5  value:44(int32)</span><span class="hljs-comment">// index:6  value:32(int32)</span><span class="hljs-comment">// index:7  value:19990(int32)</span><span class="hljs-comment">// index:10         value:30028(int32)</span></code></pre></li></ol><h2 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h2><ol><li><p>结构体的方法可以转换为函数，这个函数第一个参数就是结构体实例的指针。同理接口也一样，唯一的区别是接口本身隐含了指针。</p><pre class="highlight"><code class="go"><span class="hljs-keyword">var</span> f = (*Foo).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)<span class="hljs-keyword">type</span> SelfIntroduce <span class="hljs-keyword">interface</span> {SelfIntroduce(where <span class="hljs-type">string</span>)}<span class="hljs-keyword">var</span> f = (SelfIntroduce).SelfIntroducef(&amp;Foo{Name: <span class="hljs-string">"Tom"</span>}, <span class="hljs-string">"China"</span>)</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组和切片&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数组和切片&quot;&gt;&lt;/a&gt; 数组和切片&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化数组时可以通过索引来指定值，并且可以和按顺序指定值混用&lt;/p&gt;
&lt;pre class=&quot;highli</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>useEffect infinite loop with dependencies</title>
    <link href="http://example.com/posts/f37b0db4.html"/>
    <id>http://example.com/posts/f37b0db4.html</id>
    <published>2023-11-17T22:10:47.000Z</published>
    <updated>2023-11-17T23:04:50.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="副作用钩子useeffect"><a class="markdownIt-Anchor" href="#副作用钩子useeffect"></a> 副作用钩子：useEffect</h2><p>当需要每次在 React 组件渲染后执行某些操作时，可以通过这个钩子来注册一个副作用函数<code>effect</code>。默认情况下 React 在第一次页面渲染之后以及后续页面的每次更新后都会执行这个<code>effect</code>。</p><p>另外，副作用函数可以返回一个函数，React 会在卸载组件执行清除操作时候调用这个返回的函数，意味着可以在其中加入一些清理工作。实际上，因为 React 会在每次渲染后都会执行<code>effect</code>，它会在调用一个新的<code>effect</code>之前对前一个<code>effect</code>进行清理，所以如果页面如果发生了渲染，清理也会先执行。</p><p>useEffect 的第二个参数可以传入一个数组指定依赖的数据，当这些数据发生了变化时才执行<code>effect</code>。</p><h2 id="无限更新问题分析以及解决"><a class="markdownIt-Anchor" href="#无限更新问题分析以及解决"></a> 无限更新问题分析以及解决</h2><p>这两天写了点代码测试时发现页面出现了无限循环更新，</p><blockquote><p>Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn’t have a dependency array, or one of the dependencies changes on every render.</p></blockquote><p>主要代码如下：</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-comment">// 设置过滤器</span><span class="hljs-keyword">const</span> [filters, setFilters] = <span class="hljs-title function_">useState</span>(tags);<span class="hljs-comment">// 这里的本意是在 data 更新时更新过滤器</span><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [tags]);</code></pre><p>在这段代码中，我总认为数据从远端加载之后，<code>tags</code>没有发生变化，<code>setFilters(tags)</code> 应该只会执行一次。现实情况是，<code>setFilters(tags)</code>执行之后，页面发生了渲染，触发了<code>tags</code>的重新计算，尽管数组内容没有变化但对象发生了变化，React 再次执行<code>setFilters(tags)</code>，然后再渲染再执行……，最终 React 无限的执行<code>setFilters(tags)</code>。</p><p>其实 tags 只是一个衍生的中间量，过滤器本质是要在 data 变化后才更新，因此这段代码只需简单改下就正常了。</p><pre class="highlight"><code class="typescript"><span class="hljs-comment">// 从远程获取数据，在这里 useRequest 只会执行一次远程数据拉取，因此 data 不会发生变化。</span><span class="hljs-keyword">const</span> { data } = <span class="hljs-title function_">useRequest</span>(fetchData);<span class="hljs-comment">// 解析数据中的标签</span><span class="hljs-keyword">const</span> tags = _.<span class="hljs-title function_">uniq</span>(_.<span class="hljs-title function_">concat</span>(...(data?.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-property">tags</span>) || [])));<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {  <span class="hljs-title function_">setFilters</span>(tags);}, [data]); <span class="hljs-comment">// 这里更新依赖改为 data</span></code></pre><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a href="https://react.dev/reference/react/useEffect">Reference: useEffect</a><br><a href="https://zh-hans.react.dev/reference/react/useEffect">中文 Reference: useEffect</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;副作用钩子useeffect&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#副作用钩子useeffect&quot;&gt;&lt;/a&gt; 副作用钩子：useEffect&lt;/h2&gt;
&lt;p&gt;当需要每次在 React 组件渲染后执行某些操作时，可以通过这个钩子来</summary>
      
    
    
    
    <category term="程序" scheme="http://example.com/categories/%E7%A8%8B%E5%BA%8F/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2023-06-03T02:04:36.140Z</published>
    <updated>2023-06-03T02:05:01.626Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><pre class="highlight"><code class="bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><pre class="highlight"><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><pre class="highlight"><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><pre class="highlight"><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
